---
title: "03_community_types"
output: html_document
---
```{r}
# 安装 R 包
micromamba create -n r r-base=4.3.0 bioconductor-microbiomemarker bioconductor-deseq2 
micromamba activate r

micromamba install r-devtools r-biotyper r-reshape r-writexls r-dendsort r-seriation \
                   r-taxonomizr r-esquisse r-tidyverse r-rstatix r-PMCMR r-clValid \
                   r-philentropy bioconductor-microbiome r-RcppArmadillo=0.9.900.3.0 -y
```

```{r}
library(phyloseq)
library(microbiome)
library(DirichletMultinomial)
library(dplyr)
```

```{r}
# 检查当前工作目录
getwd()
# 如果需要，可以改变工作目录
setwd("/home/shijiabin/2025_2ME/11_viral_community_types")
getwd()
```

```{r}
#################################### 1. Create a phylseq objects ####################################
####################################
# 1.1 Genus-like groups input
# vOTU 绝对丰度表 (未稀释)
votu_abundance_file <- "01_raw_counts/votu_raw_counts.tsv"
abuntable <- read.table(votu_abundance_file, sep = "\t", header = TRUE, stringsAsFactors = FALSE)

# 读取 aai 聚类结果文件
genus_clusters_file <- "02_genus_clusters/genus_clusters.txt"
lines <- readLines(genus_clusters_file)

# 构建 vOTU -> group 映射
votu_to_group <- c()
for (i in seq_along(lines)) {
  votus <- strsplit(lines[i], "\t")[[1]]
  votus <- votus[votus != ""]
  votu_to_group[votus] <- paste0("Genus",i)
}

# 添加 group 列
abuntable$Genus_like_groups <- votu_to_group[abuntable$vOTU]

####################################
# 1.2 汇总分类注释
# 分类注释表
taxtable_file <- "/home/shijiabin/2025_2ME/05_taxonomic_classification/votu_tax.tsv"
taxtable <- read.table(taxtable_file, sep = "\t", header = TRUE, stringsAsFactors = FALSE)

# 添加 Genus_like_groups 列, 绝对丰度列
Mastertable <- merge(taxtable, abuntable, by=1, all=F)

# votu 列做行名 (方便后续的表格操作, phyloseq能够识别)
rownames(Mastertable) <- Mastertable$vOTU

# 根据原代码 https://github.com/Matthijnssenslab/IBDVirome/blob/main/IBDBiologicals/Code/PartVIII_phages_clustering.R
# 第98,141,142,153行,将原分类注释表中的Genus删掉,然后换成Genus_like_groups
Mastertable$Genus <- NULL
colnames(Mastertable)[which(names(Mastertable) == "Genus_like_groups")] <- "Genus"

####################################
# 1.5.1 Create a matrix of abundance and taxonomy tables and sample_data
# 1.5.1.1 提取丰度列然后创建矩阵
abundance_table_rarefied <- Mastertable[, grep("^raw_counts_", colnames(Mastertable))]
abundance_table_rarefied_m <- as.matrix(abundance_table_rarefied)

# 1.5.1.2 提取分类列然后创建矩阵 
target_cols <- c("Kingdom", "Phylum", "Class", "Order", "Family", "Subfamily", "Genus", "Species")
#target_cols <- c("Genus")
valid_cols <- target_cols[target_cols %in% colnames(Mastertable)]
taxonomy_table_rarefied <- Mastertable[, valid_cols, drop = FALSE]
taxonomy_table_rarefied_m <- as.matrix(taxonomy_table_rarefied)
# 显示最终的列名
cat("taxonomy tables 实际存在的列:", paste(colnames(taxonomy_table_rarefied), collapse = ", "), "\n")

# 1.5.1.3 创建 sample_data
sample_table_rarefied_for_all <- data.frame(row.names = colnames(abundance_table_rarefied))
# group: 先去掉行名最后一个下划线及之后的部分,再去掉最后一个下划线及之前的部分
sample_table_rarefied_for_all$group <- sub(".*_([^_]+)_.*", "\\1", rownames(sample_table_rarefied_for_all))

####################################
# 1.5.2 Transform to phylseq objects
ABUNDANCE_rarefied <- otu_table(abundance_table_rarefied_m, taxa_are_rows = TRUE)
TAX_rarefied <- tax_table(taxonomy_table_rarefied_m)
samples <- sample_data(sample_table_rarefied_for_all)
phyloseq_rarefied_phages <- phyloseq(ABUNDANCE_rarefied,TAX_rarefied, samples)

####################################
# 1.5.3 Visualize data & subset only the phage fraction
#sample_names(phyloseq_rarefied_phages) # All sample names
#rank_names(phyloseq_rarefied_phages) # All taxonomies
#sample_variables(phyloseq_rarefied_phages) ## All metadata
#phyloseq_rarefied_phages
```
```{r}
#################################### 2.1 Data trimming  ####################################
phyloseq_rarefied_samples1 <- phyloseq_rarefied_phages
# Filter taxa based on abundance threshold
phyloseq_phages_DMM <- phyloseq_rarefied_samples1 %>%
  microbiome::aggregate_rare(level = "Genus", detection = 0.001, prevalence = 1/100) 
# Prevalence threshold at 1% to increase accuracy because multiple samples are from the same individual (1.75% to be exact).

# 检查聚合前后的变化
cat("聚合前分类单元数:", nrow(tax_table(phyloseq_rarefied_samples1)), "\n")
cat("聚合后分类单元数:", nrow(tax_table(phyloseq_phages_DMM)), "\n")

# 检查属水平的唯一值
cat("聚合后唯一属数:", length(unique(tax_table(phyloseq_phages_DMM)[,"Genus"])), "\n")

# -----------------------------
# 新增：统计低丰度/低 prevalence 被过滤掉的行/列
# -----------------------------

# 聚合前 OTU 表
otu_before <- otu_table(phyloseq_rarefied_samples1)

# 过滤后 OTU 表
otu_after  <- otu_table(phyloseq_phages_DMM)

# 行（Genus）变化
rows_removed <- nrow(otu_before) - nrow(otu_after)
cat("被低丰度/低 prevalence 过滤掉的行数(Genus 数):", rows_removed, "\n")

# 列（samples）变化（一般不会变化）
cols_removed <- ncol(otu_before) - ncol(otu_after)
cat("被过滤掉的列数（样本数）:", cols_removed, "\n")
```
```{r}
#################################### 2.2 DMM algorithm ####################################
# Pick the OTU count matrix and convert it into samples x taxa format
dat <- abundances(phyloseq_phages_DMM)
count <- as.data.frame(t(dat))

## Remove 'Other' meaning all the unique viruses appearing only in less than X% of samples (X% abundance)
count$total <- rowSums(count)
count <- count[!count$total == 0,]  # 移除总丰度为0的行（即没有任何病毒序列的样本)
count$total <- NULL
count$Other <- NULL

## Remove samples composed of zero shared viruses
count$total <- rowSums(count)
count <- count[!count$total == 0,]
sort(rowSums(count))
count$total <- NULL

## How many samples and reads are left for determining DMM clusters?
#nrow(count) # 296 samples left for which community-typing is possible
#sum(count) # 296 samples having 2.96 billion reads
#(sum(count)/sum(Mastertable_phage$Totalnumberofreads))*100 # or 94.6% of the reads were shared

## Median genera per sample using community typing
#count_1 <- count
#count_1 <- (count_1/100)-0.01
#count_1[count_1 > 0] <- 1
#count_1 <- as.data.frame(count_1)
#count_1$prevalence <- rowSums(count_1)
#ncol(count_1) # 257 genera shared over 1% of samples with 0.01% abundance
#count_1$prevalence
#median(count_1$prevalence) # Median of 17 genera  per sample
#mean(count_1$prevalence) # Average 17.1 genera per sample

# Determine DMM clusters and evaluate BIC score
# You're matrix cannot have decimals after the komma
count <- as.matrix(count)
fit <- lapply(1:5, dmn, count = count, verbose=TRUE) 
bic  <- sapply(fit, BIC) # BIC 
aic  <- sapply(fit, AIC) # AIC 
lplc  <- sapply(fit, laplace) # laplace 
cat("lplc:", lplc, "\n")
cat("aic:", aic, "\n")
cat("bic:", bic, "\n")
#plot(bic, type="b", xlab="Number of Dirichlet Components", ylab="Model Fit")
#lines(lplc, type="b", lty = 2)
#lines(aic, type="b", lty = 3)
# 计算整体 y 轴范围
y_min <- min(c(bic, aic, lplc))
y_max <- max(c(bic, aic, lplc))

# 作图
plot(
  bic,
  type = "b",
  xlab = "Number of Dirichlet Components",
  ylab = "Model Fit",
  ylim = c(y_min, y_max)
)

lines(lplc, type = "b", lty = 2)
lines(aic,  type = "b", lty = 3)

legend(
  "topleft",
  legend = c("BIC", "Laplace", "AIC"),
  lty = c(1, 2, 3),
  bty = "n"
)

# 选择哪个准则？
# BIC: 通常在样本量较大时更受青睐，对模型复杂度惩罚更重
# AIC: 在预测准确性方面表现较好，倾向于选择较复杂的模型
# Laplace: 适用于贝叶斯模型比较
# 在实际应用中，通常会选择多个准则中结果一致的模型，或者根据具体研究目的选择最合适的准则。
```
```{r}
#################################### 2.3 Community typing ####################################
# Determine the optimal model 选择最佳模型
k <- which.min(unlist(bic))
#k <- 1
best <- fit[[k]]
# 显示最佳模型中各聚类的混合权重
#mixturewt(best)
# 显示最佳模型中每个样本的聚类分配
cat("最佳模型中每个样本的聚类分配:\n")
best@group
# 显示最佳模型的混合参数信息
#best@mixture

# 此外，评估样本属于两个DMM组中某一个的概率。如果不太感兴趣可以省略这部分
# best@group 包含了每个样本在各个聚类中的概率信息
#group_probability <- as.data.frame(best@group)
#mean(group_probability$V1)  # 计算第1个聚类的平均概率
#mean(group_probability$V2)  # 计算第2个聚类的平均概率
#median(group_probability$V1)  # 计算第1个聚类的中位数概率
#median(group_probability$V2)  # 计算第2个聚类的中位数概率

# 根据概率选择每个样本所属的主要聚类（概率最高的那个）
# Subselect the clusters for all samples as determined before
cluster <- apply(mixture(best), 1, which.max)
cluster <- as.data.frame(cluster)
cluster$cluster <- as.character(cluster$cluster)
#cat("每个聚类的样本数:\n")
#table(cluster$cluster) # cluster 1; 216 samples, cluster 2 80 samples.
cluster_phylo <- sample_data(cluster) # 将聚类结果转换为phyloseq样本数据格式，用于后续分析

# 将聚类结果添加到phyloseq对象中
phyloseq_rarefied_phages_visualization_1 <- merge_phyloseq(phyloseq_phages_DMM, cluster_phylo)

# 保存对象到文件
dir.create("03_community_types", showWarnings = FALSE)
saveRDS(
  phyloseq_rarefied_phages_visualization_1,
  file = "03_community_types/phyloseq_rarefied_phages_visualization_1.rds"
)
cat("合并肠型分析结果的 phyloseq 对象已保存到 03_community_types/phyloseq_rarefied_phages_visualization_1.rds 中 \n")
###################################
```
